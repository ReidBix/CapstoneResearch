<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Capstoneresearch by ReidBix</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Capstoneresearch</h1>
      <h2 class="project-tagline">Looking at Post Quantum Cryptography and its applications to Bitcoin and other Cryptocurrencies</h2>
      <a href="https://github.com/ReidBix/CapstoneResearch" class="btn">View on GitHub</a>
      <a href="https://github.com/ReidBix/CapstoneResearch/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/ReidBix/CapstoneResearch/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h3>
<a id="welcome-to-my-capstone-research-blog" class="anchor" href="#welcome-to-my-capstone-research-blog" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Welcome to my Capstone Research Blog.</h3>

<p>This is where I will be posting my weekly research related to a post-quantum implementation of Bitcoin. In this blog I will be looking into various topics including post-quantum signatures, effects of quantum computing on Bitcoin, benefits of switching to post-quantum algorithms, how to integrate a backwards compatible post-quantum algorithm into the Bitcoin protocol, and whatever other topics come up.</p>

<h3>
<a id="members" class="anchor" href="#members" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Members</h3>

<p>Reid Bixler (Researcher)</p>

<p>David Evans (Technical Thesis Advisor)</p>

<h3>
<a id="contact" class="anchor" href="#contact" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Contact</h3>

<p>If you have any questions or would like to contact us about my research, feel free to email either me or my technical advisor: {rmb3yz, evans}@virginia.edu</p>

<hr>

<h2>
<a id="bitcoin-locking-and-unlocking-script-alterations" class="anchor" href="#bitcoin-locking-and-unlocking-script-alterations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Bitcoin Locking and Unlocking Script Alterations</h2>

<h3>
<a id="101416---102816" class="anchor" href="#101416---102816" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>10/14/16 - 10/28/16</h3>

<h2>
<a id="current-structure" class="anchor" href="#current-structure" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Current Structure</h2>

<p>The current Bitcoin protocol is implemented in GoLang but it also has it's own Scripting language. This Scripting language is a number of Opcodes which are <em>NOT</em> Turing complete because there is no need for the language to be more complex than it needs to be, but also because a non-Turing complete language won't have loops and therefore won't have the case of the Halting Problem. If you do not know what the Halting Problem is, it is simply finding out whether or not a program will finish or not, and the introduction of loops can make a program go on infinitely. If the Bitcoin Scripting language doesn't have loops, then there is a guarantee that no program in the Bitcoin software will get stuck on a script that loops on forever. In the past there were a few Opcodes from the Bitcoin Scripting language that were removed for security reasons. For example, there used to be a simple <code>OP_RETURN</code> which had the potential to break the entire structure of Bitcoin because by passing it along with a 1 one could validate any transaction without the public key or signature (Obviously a security flaw in software intended to hold monetary value).</p>

<h2>
<a id="the-current-scripting-language" class="anchor" href="#the-current-scripting-language" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The Current Scripting Language</h2>

<p>How does the current Bitcoin Scripting Language (literally known as <code>Script</code>) work? It is a simple stack-based protocol that moves from left to right. What this means is that a user will give a Script as a list of instructions which will move items on and off of a stack. In terms of actual uses, if an Unlocking and Locking script are given, then a final stack with True on top (assuming a correct implementation of scripts) will grant access to transferred Bitcoin. The Script will contain, as stated before, opcodes, also known as <code>Words</code> which have the ability to manipulate the current stack. The words themselves look like <code>OP_NOP</code>, <code>OP_PUSHDATA1</code>, etc. but have numbers (opcodes) associated with them such as <code>97</code>, <code>76</code>, etc. respectively. There are some very complex checks of cryptography implemented into some of these words including public key verification with signatures (<code>OP_CHECKSIG</code>), RIPEMD-160 (<code>OP_RIPEMD160) and SHA256 (</code>OP_SHA256<code>) hashing, and verifying multiple public keys with multiple signatures (</code>OP_CHECKMULTISIG`). These are the core of the scripting language and are mostly what define the 5 sets of valid Locking and Unlocking Scripts.</p>

<p>What are these Locking and Unlocking Scripts anyway? These are the scripts, when in combination, that validate transactions on the Bitcoin blockchain. The Locking Script is a combination of hashing, the public Bitcoin address, and checks for the signature (Specifically, <code>OP_DUP OP_HASH160 &lt;pubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG</code> in one case). This Locking Script is often called <code>scriptPubKey</code>. For each Locking Script, there must be a valid Unlocking script that combines the signature and public key of the sending party (For the previous example, <code>&lt;sig&gt; &lt;pubKey&gt;</code> are passed). This Unlocking Script is often called <code>scriptSig</code>. With these two scripts, transactions are able to be validated on the stack by verifying the signature and public key hash, and without those the transaction won't be validated. Specifically, the Locking script is a type of "lock" placed on the outputs of a transaction that won't allow the output to be spent without the verification of the "key" (i.e. Unlocking Script). Every Bitcoin client intending to verify all the transactions must take the given Locking Script on the inputs run the Unlocking Script (given with the input itself) and execute the scripts together. However, there is not just one way to run Locking and Unlocking Scripts, in fact there are multiple. The one referenced previously is known as a Pay-to-Public-Key-Hash (P2PKH) because it is paying to the hash of a public key. This is predominantly used in the blockchain, but there do exist other payment methods like Pay-to-Public-Key (P2PK) and Multi-Signature.</p>

<p>One large thing of note is that P2PK will become completely invalidated if quantum computers become available. The reasoning behind this is that P2PK assumes that the outputs are locked with the Public Key (Like so, <code>&lt;Public Key A&gt; OP_CHECKSIG</code>) which in a "quantum world" would be 'easy' to break and find the private key for. If somebody wants to steal money from this address they would have to simply give the signature from the private key (Like so, <code>&lt;Signature from Private Key A&gt;</code>) which would grant access to the stored Bitcoin. At least in the P2PKH instance, the Locking script runs on top of the Bitcoin address (a hashed version of the public key), which would make it 'hard' to find the public key, and therefore 'hard' to break and find the private key. Therefore, up until the Unlocking Script is run (and the Public Key is broadcasted by the intended recipient), any Bitcoin outputs will be safe from quantum-attack <em>ASSUMING</em> that the Public Key has not yet been broadcasted.</p>

<h2>
<a id="bliss-integration" class="anchor" href="#bliss-integration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>BLISS Integration</h2>

<p>As talked about in our previous post, BLISS will be our desired post-quantum signature for the Bitcoin protocol. The big question is how we can ensure that this signature is being verified alongside the original signature. We want to be able to create Scripts that simultaneously verify the ECDSA signature as well as the BLISS signature, and guarantee a failure if either fails (specifically the case when ECDSA succeeds and BLISS fails, which would be a sign of a quantum-attack). The largest problem right now is simply the fact that the <code>Script</code> does not yet contain Opcodes for verifying a BLISS signature. Until an Opcode for this verification is available, there can be no unlocking or locking scripts that can ensure security against quantum computers. However, in this case, I am going to move forward assuming that there exists a word known as <code>OP_CHECKBLISS</code> which when given a stack of <code>&lt;PUB KEY BLISS&gt; &lt;SIG BLISS&gt;</code> will return a result of <code>TRUE</code> on the stack (essentially verifying that the public key shown is generated from the same private key of the signature).</p>

<p>We can now go about determining what would be the best course of action for creating a valid Unlocking and Locking Script with the given Opcode. Simply, we will be having our Unlocking script have both our Public Keys and Signatures from ECDSA and BLISS, and our Locking Script will have our verifications first of the ECDSA then of the BLISS, and finally comparing those two outputs to determine if they are both true (a simple AND instruction). With this in place, we can ensure that any transaction containing Locked with these Scripts will only be unlocked with a valid and quantum-secure BLISS signature.</p>

<h2>
<a id="interesting-thingsprevious-research" class="anchor" href="#interesting-thingsprevious-research" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Interesting Things/Previous Research</h2>

<p>It turns out that earlier this year a man by the name of Leon Groot Bruinderink released a paper on possible side-channel attacks on an implementation of post-quantum Bitcoin that uses the BLISS protocol. That paper can be found here (<a href="http://www.leongb.nl/wp-content/uploads/2016/03/Thesis.pdf">http://www.leongb.nl/wp-content/uploads/2016/03/Thesis.pdf</a>). This is an extremely interesting look at the possible types of attacks on our potential implementation of BLISS into Bitcoin, as well as the possible ways to prevent such attacks.</p>

<h2>
<a id="other-sources" class="anchor" href="#other-sources" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Other Sources</h2>

<ul>
<li><a href="http://chimera.labs.oreilly.com/books/1234000001802/ch05.html#p2pkh">http://chimera.labs.oreilly.com/books/1234000001802/ch05.html#p2pkh</a></li>
<li><a href="https://en.bitcoin.it/wiki/Script">https://en.bitcoin.it/wiki/Script</a></li>
</ul>

<hr>

<h2>
<a id="post-quantum-implementation-into-bitcoin-analysis" class="anchor" href="#post-quantum-implementation-into-bitcoin-analysis" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Post-Quantum Implementation into Bitcoin Analysis</h2>

<h3>
<a id="93016---101416" class="anchor" href="#93016---101416" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>9/30/16 - 10/14/16</h3>

<h2>
<a id="risks-of-non-implementation" class="anchor" href="#risks-of-non-implementation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Risks of Non-implementation</h2>

<p>As stated previously, the ECDSA algorithm is no longer “hard” using a modification of Shor’s algorithm. This means that any service currently using the ECDSA algorithm has the potential to be hacked or broken by a quantum computer. In terms of the Bitcoin protocol, what would be the consequences in the breaking of the ECDSA algorithm? The Bitcoin protocol uses ECDSA to generate public and private key pairs which are used to sign transactions and verifying those same transactions. The private key is specifically used to sign any transaction that you choose to put onto the block chain. This means that you can create a transaction designated that you will send 1 Bitcoin to person X, followed by signing a signature of that transaction with your private key Pr. The Bitcoin network in turn sees that transaction and verifies your given signature with your publically available public key Pu. As long as the signature can be verified with the public key, then the transaction will most likely go through and onto the block chain. The security of ECDSA relies on the fact that it is provably “hard” to calculate the private key Pr from the available public key P¬u. However, a functioning quantum computer would be able to relatively easily derive the private key from any given public key. This control of a private key does not give total control over the user’s Bitcoins, but it does pose risks for some users. Specifically, this poses a risk to users who choose to only stick with one private key, as in users that use the same Bitcoin address repeatedly. However, the Bitcoin protocol protects your Bitcoin address with the usage of multiple hash functions used on the public key to generate the user’s Bitcoin address. The protocol is as follows:</p>

<p>What this generally means for Bitcoin users is that your address will not be the source of your leaked private key (assuming a functioning quantum computer). So all that means is that we don’t have to give away our public key, right? Well, the problem is that nobody can verify your transaction signatures without your publically broadcasted public key. This means that until you broadcast your public key, your address is perfectly safe from quantum attacks (assuming that the hashing functions SHA256 and RIPEMD-160 remain quantum resistant, but that would lead to even larger problems). However, once your public key is broadcast to verify a transaction, any leftover Bitcoin in that address is at risk of being attacked and robbed by a quantum computer. Once your transaction and public key are available, a maligned entity with a quantum computer can brute force your private key, impersonate you with it, create a transaction transferring any leftover Bitcoin to their own address, and get off scot-free (assuming the Bitcoin community would be unwilling to reverse the transaction). However, there is yet another problem present with the introduction of a quantum computer. The Bitcoin community is built up from a multitude of nodes throughout the world who receive and send Bitcoin transactions to the Bitcoin miners that eventually place your transactions in the block chain. If one of those nodes that you attempt to send to has a quantum computer, they could receive your intended transaction, forge your private key, create a new transaction changing the intended address, and send it on its way to the mining pools. So what is a solution to this? Simply make every Bitcoin address a one-time use address. While this principle is carried out quite often in the Bitcoin block chain, there are still many cases of businesses, organizations, and the like who reuse a Bitcoin address for ease of use. In fact, there exist many Bitcoin addresses on the block chain that are holding hundreds of Bitcoin and have already publically broadcast their public key. However, this solution assumes that every Bitcoin node and Bitcoin mining pool are trustworthy and do not have quantum computers. If any receiving node or mining pool is malicious and owns a functioning quantum computer, they can spend your Bitcoin even before your transaction becomes technically available to the public! While the majority of Bitcoin may be safe, any security risk to the protocol must be mitigated as soon as possible, assuming a future of working quantum computers.</p>

<h2>
<a id="the-protocol" class="anchor" href="#the-protocol" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The Protocol</h2>

<p>We have discussed previously about the possible post-quantum algorithms that can be applied for use in the Bitcoin protocol, and have come down to using the BLISS protocol as our quantum-resistant algorithm. However, the problem that we are presented with is integrating this into the current protocol while still maintaining the previous functionality, also known as backwards compatibility. If we required a hard fork from the entire Bitcoin community, we would see a split similar to that of Ethereum earlier this past summer. Many users would not consider the threat of quantum computers large enough to switch over to using a new protocol entirely, while some would like to ensure the overall security before the likelihood of an attack. Therefore, we pose the notion that we derive the private ECDSA key from our private quantum key, and requiring the verification of both the ECDSA signature and quantum signature. Early adopters of this protocol would be required to put out a message to the block chain stating something along the lines of “do not accept any transactions from this address without the verification of my quantum signature”. Eventually, once enough traction is gained, or when the first attack on ECDSA is discovered, Bitcoin miners will only add transactions with the quantum signatures in addition to the ECDSA signatures. In the worst case, nobody will use a quantum resistant Bitcoin protocol until an attack is carried out. However, this is a huge risk considering once again why Ethereum split earlier (<a href="http://www.coindesk.com/ethereum-classic-explained-blockchain/">http://www.coindesk.com/ethereum-classic-explained-blockchain/</a>). If Bitcoin users only wait until they are attacked, they run the risk of losing a majority of the value in Bitcoin from a major split between users. By implementing an entirely backwards-compatible AND quantum resistant protocol into Bitcoin, we can slowly integrate quantum resistance into Bitcoin while not alienating users who do not yet wish to join. The problems that we see with integrating this is maintaining the functionality as well as minimizing the weight of this new protocol. Noticeably many new quantum-resistant signatures require massive key sizes as well as significantly longer signing and verification times. Seeing as the Bitcoin community is already having problems with scaling up transaction volume, adding additional unnecessary weight from massive keys and long waiting times would be infeasible. This is where the BLISS protocol comes into play. As far as my research has come to, the BLISS protocol is the most viable quantum-resistant protocol because of the significantly smaller key sizes and signing/verification times in comparison to other quantum-resistant signature algorithms. Similar to a previous table here is a more in depth look at the requirements behind the BLISS protocol:</p>

<p>A good comparison between different quantum-resistant signature schemes and current schemes was produced which at least shows the viability of BLISS:</p>

<p>As can be seen from the chart above, BLISS is the best performing protocol of all the tested algorithms, although it does obviously worse in terms of key size compared to current protocols. In terms of creating an ECDSA private key from a BLISS private key, we would have to hash the BLISS private key to produce our required ECDSA private key. While the hashing obviously has its benefits from the quantum-resistance, it is required to scale down the larger size of the BLISS key. The actual creation of a private key is creating 2 matrices that satisfy the BLISS protocol such that it follows the following scheme:</p>

<p>Once our two keys A and S are generated, we can hash them down with a chosen hashing scheme (SHA-256, BLAKE-256, HAVAL etc.) that guarantees an ECDSA sized private key (256 bits). I intend to look into creating an example of this for a later post. In the best case, we can ensure the complete security of Bitcoin, while still maintaining the current functionality of the protocol.</p>

<h2>
<a id="other-sources-1" class="anchor" href="#other-sources-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Other Sources</h2>

<ul>
<li><a href="http://www.bitcoinnotbombs.com/bitcoin-vs-the-nsas-quantum-computer/">http://www.bitcoinnotbombs.com/bitcoin-vs-the-nsas-quantum-computer/</a></li>
<li><a href="https://bitcoinmagazine.com/articles/bitcoin-is-not-quantum-safe-and-how-we-can-fix-1375242150">https://bitcoinmagazine.com/articles/bitcoin-is-not-quantum-safe-and-how-we-can-fix-1375242150</a></li>
<li><a href="http://www.smithandcrown.com/8655/">http://www.smithandcrown.com/8655/</a></li>
<li><a href="http://www.nicolascourtois.com/bitcoin/thesis_Di_Wang.pdf#page=27">http://www.nicolascourtois.com/bitcoin/thesis_Di_Wang.pdf#page=27</a></li>
<li><a href="http://csrc.nist.gov/groups/ST/post-quantum-2015/presentations/session9-oneill-maire.pdf">http://csrc.nist.gov/groups/ST/post-quantum-2015/presentations/session9-oneill-maire.pdf</a></li>
<li><a href="http://www.etsi.org/images/files/ETSIWhitePapers/QuantumSafeWhitepaper.pdf">http://www.etsi.org/images/files/ETSIWhitePapers/QuantumSafeWhitepaper.pdf</a></li>
</ul>

<hr>

<h2>
<a id="introduction-to-quantum-signatures" class="anchor" href="#introduction-to-quantum-signatures" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction to Quantum Signatures</h2>

<h3>
<a id="91716---93016" class="anchor" href="#91716---93016" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>9/17/16 - 9/30/16</h3>

<h2>
<a id="background" class="anchor" href="#background" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Background</h2>

<p>Digital signatures are used pretty much everywhere on the internet, specifically for Authentication, Integrity, and Non-repudiation. A lot of the security of the net relies on the fact that these digital signatures are truly secure and won’t be ‘easily’ broken. With the coming potential of quantum computers, there is a growing need for quantum secure algorithms and signatures alike. Many quantum-resistant encryption algorithms have been proposed, but most have not been designed to support signatures. In this post, I am going to look into the applications of some quantum signatures and their usefulness in current technologies.</p>

<h2>
<a id="lattice-signatures" class="anchor" href="#lattice-signatures" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Lattice Signatures</h2>

<p>I'm first going to look at Lattice-Based cryptography, based off of the fact that it is often the most cited and used form of post-quantum cryptography. In future posts, we'll get more into how lattice cryptography works, but for now we will describe some current signature schemes.</p>

<h3>
<a id="ring-lwe-signatures" class="anchor" href="#ring-lwe-signatures" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Ring-LWE Signatures</h3>

<p>(<a href="http://eprint.iacr.org/2011/537.pdf">http://eprint.iacr.org/2011/537.pdf</a>)</p>

<p>Ring Learning with Error is based on the arithmetic of polynomials with coefficients from a finite field. In 2011, Lyubashevsky came up with the application of the Ring-LWE structure for signatures based off of the worst-case hardness of the Shortest Independent Vectors Problem (SIVP) in general lattices. In his paper, he looks at the Small Integer Solution (SIS) problem and its application to a signature scheme based off of its provable hardness. The requirements behind the signature are a secret key of m x k matrix of S random integers and a signer must pick an m-dimensional vector y from a distribution D which then is used to compute c such that ( c = H(Ay,m) ) which is then used to compute z such that ( z = Sc+y ). The signature that the signer will output is (z,c), put there is a probability that a signature will not be outputted, at which point the signer will run the algorithm until a signature is outputted. The signature length and key size can change based off of the signers choosing, but there are certain security implications if those values are too small. Later in the paper, applications of SIS and LWE define a Ring Variant of a SIS signature which is provably improved from the previous two signature schemes. Specifically, the scheme defines a secret key s1,…, sγ where every coefficient of si is chosen uniformly and independently from a predefined range. A public key is created (a1,…, aγ, t) where each ai is uniformly random and t is defined as the sum of each multiple of ai and si. A message is signed, which can be verified easily with the public key. This scheme is based on the provable hardness of the ring variant of the SIS problem. This final ring variant is the Ring-LWE Signature provided by Lyubashevsky.</p>

<h3>
<a id="ggh-signatures" class="anchor" href="#ggh-signatures" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GGH Signatures</h3>

<p>(<a href="http://eprint.iacr.org/1996/016.ps">http://eprint.iacr.org/1996/016.ps</a>)</p>

<p>The Goldreich-Goldwasser-Halevi signature scheme was published in 1997 and is based on the Closest Vector Problem (CVP) which is also a lattice based problem. Signers show their message using a lattice, which the verifier then verifies on the different lattice point sufficiently close to the previously designated message point of the same lattice. The GGH signature scheme is more based on an encryption algorithm but the application to signatures is perfectly viable, while difficult.</p>

<h3>
<a id="ntrusign" class="anchor" href="#ntrusign" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>NTRUSign</h3>

<p>(<a href="http://grouper.ieee.org/groups/1363/WorkingGroup/presentations/NTRUSign-2005-08.ppt">http://grouper.ieee.org/groups/1363/WorkingGroup/presentations/NTRUSign-2005-08.ppt</a>)</p>

<p>NTRUSign is based on the GGH signature scheme which was put into publication in 2003, but was revised with parameter recommendations in 2005. This signature scheme uses 2 short polynomials in a ring which are then used to place the intended message in a 2N-dimensional space. One of the problems presented with NTRUSign is the fact that a transcript of signatures can leak information about the private key. After the creators reformed their parameter recommendations in 2005, they suggested that 20^30 signatures were needed to possibly find the private key, however a recent 2012 analysis of NTRUSign proved that they only needed about a couple thousand signatures to provably find the private key.</p>

<h3>
<a id="bliss" class="anchor" href="#bliss" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>BLISS</h3>

<p>(<a href="http://eprint.iacr.org/2013/383.pdf">http://eprint.iacr.org/2013/383.pdf</a>)</p>

<p>Finally, and most importantly, in 2013 the BLISS protocol was introduced as a solution to all the previously broken signature schemes introduced. BLISS is very similar to Ring-LWE in structure, but has some notable changes which allow for it to (so far) not give away the secret key over consistent usage. The signature and verification algorithm are shown below:
<img src="http://imgur.com/rVMwR7l" alt=""></p>

<p>However, there were optimizations introduced later in the publication, specifically defining the BLISS signature scheme:
<img src="http://imgur.com/Ld96OYB" alt=""></p>

<p>Using the BLISS signature scheme for future signatures look to prove quite useful, however compared to current schemes there are noticeable drawbacks:
<img src="http://imgur.com/34MHKtO" alt=""></p>

<p>The BLISS scheme noticeably takes more space than RSA or ECDSA, but this is the most applicable and secure implementation of lattice-based cryptography so far. </p>

<h2>
<a id="multivariate-signatures" class="anchor" href="#multivariate-signatures" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Multivariate Signatures</h2>

<p>This type of cryptography is based off of multivariate polynomials over a finite field. One of the ‘benefits’ of multivariate cryptography is the fact that it is extremely useful in the application of signatures, but all encryption schemes using multivariate cryptography have failed. In this post, I intend on going strictly into the viability of Lattice Signatures, but I am adding the types of signature schemes I may look at in the future.</p>

<h3>
<a id="cyclicrainbow" class="anchor" href="#cyclicrainbow" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>CyclicRainbow</h3>

<p>(<a href="https://eprint.iacr.org/2010/424.pdf">https://eprint.iacr.org/2010/424.pdf</a>)</p>

<h3>
<a id="mi-t-hfe" class="anchor" href="#mi-t-hfe" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>MI-T-HFE</h3>

<p>(<a href="https://eprint.iacr.org/2015/890.pdf">https://eprint.iacr.org/2015/890.pdf</a>)</p>

<h3>
<a id="gui" class="anchor" href="#gui" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GUI</h3>

<p>(<a href="http://csrc.nist.gov/groups/ST/post-quantum-2015/papers/session1-ding-paper.pdf">http://csrc.nist.gov/groups/ST/post-quantum-2015/papers/session1-ding-paper.pdf</a>)</p>

<h2>
<a id="hash-based-signatures" class="anchor" href="#hash-based-signatures" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Hash-Based Signatures</h2>

<p>Hash signatures have been around since around 1970 ever since Ralph Merkle came up with the idea of the Merkle Trees as an alternative to RSA and DSA. The interesting thing about hash signatures are that the use of hashing is already widely used, but has been proven to be quantum resistant unlike some of the other current encryption methods. This means that using hash-based signatures could prove easier to implement into future technologies simply because people are more used to them. Similarly to the previous section, I will go into this more on future posts.</p>

<h3>
<a id="merkle" class="anchor" href="#merkle" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Merkle</h3>

<p>(<a href="https://www.emsec.rub.de/media/crypto/attachments/files/2011/04/becker_1.pdf">https://www.emsec.rub.de/media/crypto/attachments/files/2011/04/becker_1.pdf</a>)</p>

<h3>
<a id="lamport" class="anchor" href="#lamport" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Lamport</h3>

<p>(<a href="http://csrc.nist.gov/groups/ST/hash/documents/preneel_nist_v2.pdf">http://csrc.nist.gov/groups/ST/hash/documents/preneel_nist_v2.pdf</a>)</p>

<h2>
<a id="code-based-signatures" class="anchor" href="#code-based-signatures" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Code-Based Signatures</h2>

<p>Code-Based encryption schemes are based on the general hardness of decoding a general linear code. McEliece and Niederreiter encryption algorithms were discovered in the late 20th century, but the problem with code-based signatures is there will be very large key sizes required. Because of this problem, the code-based cryptography has only seen potential application to encryption schemes and not as much into signature schemes.</p>

<h3>
<a id="code-based-signatures-1" class="anchor" href="#code-based-signatures-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Code-based Signatures</h3>

<p>(<a href="https://arxiv.org/pdf/1312.4265v1.pdf">https://arxiv.org/pdf/1312.4265v1.pdf</a>)</p>

<h3>
<a id="sterns-scheme" class="anchor" href="#sterns-scheme" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Stern's Scheme</h3>

<p>(<a href="https://eprint.iacr.org/2014/163.pdf">https://eprint.iacr.org/2014/163.pdf</a>)</p>

<h2>
<a id="post-quantum-signatures-conclusion" class="anchor" href="#post-quantum-signatures-conclusion" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Post-Quantum Signatures Conclusion</h2>

<p>There exist quite a number of signature schemes that have proven to be quantum resistant. In terms of applications, the most likely forms we may use will be Lattice-Based or Multivariate signature schemes. However, the biggest problem that we will see in the implementation of quantum resistant signatures are the large key sizes in comparison to current key sizes. This means that many protocols will need to be changed to work with the new signature schemes, as introduced in the suggestion of Transport Layer Security (TLS) and Internet Key Exchange (IKE). Another problem that remains to be solved is the fact that many of these quantum resistant algorithms are not guaranteed to be quantum resistant. To better explain, the only reason why some algorithms like RSA and ECDSA are provably broken by quantum computing is because of the creation of Shor’s Algorithm which shows that quantum will break the foundation of prime factorization. The current post-quantum algorithms rely on both a NP-Hard problem as well as not having a quantum algorithm that breaks that hardness. While there currently do not exist any solutions to Lattice-Based or Multivariate problems with quantum computing, that does not mean that there will not exist such algorithms in the future. The security of all these quantum-resistant schemes are based on the assumption that there will not be an algorithm found to break the schemes. Regardless of this, striving to improve the security of the internet and technology is paramount. These quantum algorithms hold just as much security as current cryptographic algorithms do today, because they are based on NP-Hard problems that have no solutions capable of breaking the security of the algorithms.</p>

<h2>
<a id="other-sources-2" class="anchor" href="#other-sources-2" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Other Sources</h2>

<ul>
<li><a href="https://eprint.iacr.org/2004/297.pdf">https://eprint.iacr.org/2004/297.pdf</a></li>
<li><a href="http://eprint.iacr.org/2013/383.pdf">http://eprint.iacr.org/2013/383.pdf</a></li>
<li>
<a href="http://www.di.ens.fr/%7Educas/NTRUSign_Cryptanalysis/DucasNin">http://www.di.ens.fr/~ducas/NTRUSign_Cryptanalysis/DucasNin</a> guyen_Learning.pdf</li>
</ul>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/ReidBix/CapstoneResearch">Capstoneresearch</a> is maintained by <a href="https://github.com/ReidBix">ReidBix</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
